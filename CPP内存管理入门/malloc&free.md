## vc6.0 malloc设计一览
### SBH（small block heap）之始 _heap_init()和__sbh_heap_init()
#### _heap_init()里的操作一览
  - HeapCreate()向操作系统申请内存块,赋值给_crtheap,方便以后进行管理,准备16个Header，每个Header首部用64个二进制位来标志当前Header上链表的使用状态

## vc6.0 malloc执行顺序-->调用栈顺序(debug模式下调用)
- 在程序进入main函数之前进行的初始化操作
- 1. _heap_init():堆初始化
- 2. _ioinit():io初始化，第一次分配内存,分配256字节,即100H
- 3. _heap_alloc_dbg:调整内存区块大小和补充内存块信息,第二次分配内存，分配调整过后的大小,同时做调整内存块指针的工作，基本可以看成是free_list构建链表间指针的操作,而且一直持有链表指针，就算把内存分配给客户之后，也掌握着链表的指向，存储着内存的信息
- 4. _heap_alloc_base:检查调整过后的Block大小，如果小于或等于小区块大小(1016=1024-8bytes)，那么交给sbh进行分配，否则交给操作系统进行分配
- 5. __sbh_alloc_block:加上8bytes的cookie，同时对内存大小进行上调到16的倍数
- 6. __sbh_alloc_new_region:一个header内含有两个指针，一个指针指向实际逻辑内存地址的位置，一个指针指向内存管理空间，也就是region．region负责管理当前内存块的使用情况．region持有32个tagGroup，每个tagGroup持有两个指针，做出一个双向链表，总共有64条双向链表.总共16k左右．为了良好管理虚拟内存的使用情况．此函数调用的结果是获取一块新的region，以供管理使用．
- 7. __sbh_alloc_new_group:将虚拟内存进行切块划分，同时将每一块串到上面分配好的region里的最后一个group指针上进行管理，每一块都和附近的块进行串联，形成一整块的链表队列．
  - 最后一条链表的特殊之处：所有大于1kb的块，均归它所管
  - tagEntry(4096bytes):将虚拟内存切块划分的单位，持有块大小，前后块等信息．以及保留数据块，提供给用户使用．前后块指针方便将每一块串起来，串成一个双向链表，提供给region的group块进行管理
  - malloc和free本质是group里的双向链表之间指针的变动
  - group块进行切割分配，将本身内部保留区的指针给传到外部，那么客户就认为自己获得了这一块内存的所有权．切割的时候获得的指针是指向cookie头的，在return回去的时候，要将指针进行偏移，直到指向真正的客户使用区块．
  - 每分配一块内存给客户，那块内存前后都夹有无人区，方便编译器检测，是否超过内存边界．
- 找寻新的内存区块进行分配的时候，如果对应位置上的链表没有管理内存区块，是空链表，那么会在region中往后寻找最接近的链表，找到之后再在对应链表管理的区块上进行切割．
- 如果在当前索引的group上都找不到合适的区块的话，那么会跳到下一个group进行内存区块分配．

## vc6.0 free执行特点分析
- 先计算出对应链表位置进行回收，之后将目的区块无人区的大小进行变动(-1)，则视为该区块已经回收．
- 同时在对应区块上embeded pointer链接回计算出的链表(group)
- 修改region上对应链表的状态，如果本身region对应位上的链表没有区块，挂上回收的区块之后，视为正在管理区块的链表，将其状态位修改为１．如果本身已经管理有区块，则不需要修改．如果回收之后，链表管理区块为空，那么region也需要对应修改．
- free之时，在pages中，如果上下存在空闲区块，那么会进行上合并或者下合并或者上下一起合并．
- 上下cookie（无人区）的作用：回收内存块的时候，进行检查上下cookie，在进行cookie大小进行变动的时候，如果检查到上cookie或者下cookie是为空标志，那么就可以进行合并．如果没有下cookie，那么就无法进行上合并．本质是检查无人区最后一位是否为０，如果为０则表明该区块是空区块．
- free时，要先找到Header，然后找到对应的group，之后再将其挂上fre_list上
- 分段管理可以区分责任，方便从系统申请和归还
- 全回收：看group首部cntEntries，如果为0则回收此块内存,全回收之时，调用VirtualFree还回操作系统。有两个group可以归还的时候才进行全回收的归还动作。
- Defering:有__sbh_pHeaderDefer是一个指针，指向一个全回收group所属的Header，当一个新的全回收group出现，才将这个group给归还给操作系统，同时Defer指针指向新出现的全回收group.如果出现新的分配block请求，那么会从Defer group中取出block完成分配，同时Defer指针会取消。
- __sbh_indGroupDefer是个索引，指出Region中哪个group是Defer.
- 在分配block之前，会先检查Header的计数器是否为0,如果为0,那么就看Header是否Defer且此次所用的group是否Defer.都吻合的话就取消其Defer身份(令__sbh_pHeaderDefer为null)
- 当归还完所有内存时，就会恢复到初始状态，也就是调用__heap_init状态

## vc6.0 malloc&free学习总结
- 由上至下的allocator->new->malloc->virtual_alloc一层层的封装抽象之下，每一层都不知道临近层的实现，且不互相依赖。其传递的都是信息。
- allocator设计为了避免cookie的空间浪费，new为了封装malloc，给类对象层次之间多一层抽象，而malloc为了减少virtual_alloc的调用次数，以及内存碎块问题，尽心尽力。
- 由此观之，可以大概得出结论：如果不是特别需求，new足以满足日常的内存分配需要，而且在性能和碎块数量都良好的情况下，高层业务逻辑设计已经不太需要自己再重头设计一个内存池之类的抽象。
