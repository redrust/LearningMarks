# 第5章 对象复制
## 1.除了对象的复制数据，数据包中的复制对象状态应该包含哪三个关键值？
- [答]：1）对象类型 2）对象全局唯一ID 3）数据包类型

## 2.为什么网络代码依赖游戏代码是不可取的？
- [答]：1）游戏中每次添加一个新的需要同步状态的类，都需要在网络代码中增加对应的创建生成代码，容易遗漏。 2）在新游戏中都需要重写相关的网络代码，无法代码复用，带来人力上的浪费。 3）很难进行单元测试，因为每次加载网络单元的时候都需要加载游戏逻辑单元。

## 3.解释一下，如何在网络代码不依赖游戏代码的情况下，在接收端支持复制对象的创建？
- [答]：1）需要复制的对象，提供唯一的对象类型标识，以及创建该类对象的接口。 2）每个需要复制的对象，拥有全局唯一的ID。 3）实现对象注册创建中心，该中心记录了每个类型的创建接口，根据读取到的网络数据，确定当前读取的数据对象，是需要通过哪个接口进行创建。

## 4.实现一个包含5个移动对象的简单游戏。通过以每秒15次的频率给远程主机发送世界状态数据包，来给远程主机复制这些对象。
## 5.考虑问题4中的这个游戏，当游戏对象数量增加时会出现什么问题？如何解决这个问题？
- [答]：当游戏对象数量增加时，世界状态数据包也会随之不断增大，对网络带宽带来不小的压力。可以使用增量同步的方式处理这个问题，在每次同步的对象状态的时候，只同步修改了的数据值，而不是同步整个对象。
## 6.实现一个系统，支持给远程主机发送一个对象部分属性的更新。
- [答]：1）数据包定义，声明该数据包类型是更新对象部分属性。 2）注册中心，注册该对象的方法。 3）解析派发器，解析该数据包的数据，获取到数据包中需要更新对象的ID，在全局对象表中查找对象，再根据对象传入方法调用的参数进行方法调用。
## 7.什么是RPC？什么是RMI？两者的区别是什么？
- [答]：RPC(Remote Procedure Call)：远程过程调用。RMI(Remote Method Invocation):远程方法调用。RPC是客户机调用服务器的方法，或者相反。而RMI是针对某一特定对象身上的方法进行调用.
## 8.使用本章的框架,实现RPC的SetPlayerName(const string& inName)方法，告诉其他主机本地玩家的名字。
## 9.实现一个自定义数据包类型，使用合理有效的带宽复制玩家当前在键盘上按下的键。解释一下，如何将该实现融入到本章的复制框架中。
- [答]：使用比特位进行输入按键的复制，可以有效减少带宽。如果对输入按键限制为英文字母区，那么4字节数据包即可覆盖所有的输入。在ReplicationAction中增加RA_Input枚举变量，在ReplicationManager中增加特定的序列化和反序列化方法，在ReplicationManager::ProcessReplicationAction中增加RA_Input数据包类型的操作，调用前面实现的序列化和反序列化方法。