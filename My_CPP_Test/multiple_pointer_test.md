## 多重指针测试
```cpp
int main()
{
    typedef int T;
    //声明一个常量
    const T t = 12345;
    //一个指向变量的指针
    T* pt;
    //指向常指针的指针变量
    //一次罪恶的类型转换
    const T** ppt = (const T**)&pt;
    //提领二级指针的值,也就是一级指针pt
    //将其指向常量t
    *ppt = &t;
    //在这个例子里,一级指针也就是pt,是个普通指针
    //于是可以对其进行赋值操作
    //从而破坏了t的常量性
    *pt = 54321;
    //t的值也确实没有发生变化
    std::cout << t << std::endl;
    //但是如果再有一个指向常量的指针指向t
    //进行提领的话,那么就会变成上面的值
    //导致了t的值的二意性
    const T* pct = &t;
    std::cout << *pct << std::endl;
    return 0;
}
/*
输出结果如下:
12345
54321
*/
```
- 总结:二级指针与强制类型转换,往往会带来意想不到的结果。因为指向指针的指针往往无法保证其内含指针行为的正确性。在这点上,使用引用或者标准库容器来进行裸指针的管理,会是更理想的选择。