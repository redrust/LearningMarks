# 语言特性

## 1.迭代器和泛型for
### 1.迭代器和闭包
- 迭代器是一种可以让我们遍历一个集合中所有元素的代码结构.
- 闭包是一个可以访问其自身的环境中一个或多个局部变量的函数．
```lua
function values(t)
    local i = 0; -- 内部索引变量
    return function() i = i + 1; return t[i]; end --返回一个函数,指向对应位置的值
end

t = {10,20,30};
iter = values(t); -- 创建迭代器
while true do
    local element = iter(); -- 调用迭代器
    if element == nil then break end
    print(element);
end
```
### 2.泛型for
- 泛型for自身会保存迭代状态．
```lua
-- 范型for的语法如下
for var-list in exp-list do
    body
end
```
- var-list是由一个或多个变量名组成的列表，以逗号分隔
- exp-list是一个或多个表达式组成的列表,同样以逗号分隔
- 变量列表第一个变量称为控制变量，其值在循环过程中永远不会是nil，因为当其值为nil时循环就结束了

### 3.无状态迭代器
- 自身不保存任何状态的迭代器.
```lua
-- 根据当前值来迭代生成下一个值的迭代器
a = {"one","two","three"};
for i,v in ipairs(a) do
    print(i,v);
end
```

### 4.按顺序遍历表
- 使用一个中间数组来进行排序操作
```lua
lines = {
    ["c"] = 10,
    ["b"] = 5,
    ["a"] = 20
};
function pairsByKeys(t,f)
    local a = {};
    for n in pairs(t) do -- 创建一个包含所有键的表
        a[#a + 1] = n;
    end
    table.sort(a,f); -- 对列表排序
    local i = 0; -- 迭代变量
    return function() -- 迭代函数
        i = i + 1;
        return a[i],t[a[i]]; -- 返回键和值
    end
end

for name,line in pairsByKeys(lines) do
    print(name,line);
end
```

## 2.元表和元方法
### 1.元表
- 元表可以修改一个值在面对一个未知操作时的行为.
- 字符串标准库为所有的字符串都设置了同一个元表,其他类型在默认情况中都没有元表
- 与面向对象中的受限制类相似，不过元表只能给出预先定义的操作集合的行为
```lua
-- Set.lua
Set = {};
local mt = {}; -- 集合的元表

-- 使用指定的列表创建一个新的集合
function Set.new(l)
    local set = {};
    setmetatable(set,mt);
    for _,v in ipairs(l) do set[v] = true end-- 使用无状态迭代器将列表的每个元素插入到表中
    return set;
end

-- 交集
function Set.union(a,b)
    local res = Set.new{};
    for k in pairs(a) do res[k] = true end
    for k in pairs(b) do res[k] = true end
    return res;
end

-- 差集
function Set.intersection(a,b)
    local res = Set.new{};
    for k in pairs(a) do
        res[k] = b[k];
    end
    return res;
end

-- 将集合表示为字符串
function Set.tostring(set)
    local l = {}; -- 保存集合中所有元素的列表
    for e in pairs(set) do
        l[#l + 1] = tostring(e)
    end
    return "{" .. table.concat(l,", ") .. "}";
end

-- 定义元方法
mt.__add = Set.union;
mt.__mul = Set.intersection;

return Set;

-- test.lua
require "Set"
-- 所有由Set.new创建的集合都具有了一个相同的元表
s1 = Set.new{10,20,30,40};
s2 = Set.new{10,2};
s3 = s1 + s2;
```
### 2.元方法
- 算数运算符的元方法
  - 加法:__add 乘法:__mul 减法:__sub 除法:__div floor除法:__idiv 负数:__unm 取模:__mod 幂运算:__pow
- 位运算符的元方法
  - 按位与:__band 按位或:__bor 按位异或:__bxor 按位取反:__bnot 向左位移:__shl 向右位移:__shr
- 关系运算符的元方法
  - 等于:__eq 小于:__lt 小于等于:__le
- 格式化输出元方法:__tostring
- 保护元表方法:__metatable
- 遍历元方法:__pairs
- __index元方法
  - 当索引一个表中不存在的元素时，最终的元方法处理返回结果
  - 此元方法不仅可以声明成函数，亦可以声明成表
  - 如果此元方法是一个表，则在这个表中进行查询
- __newindex元方法
  - 当表进行赋值操作时，如果不存在索引，则会调用该元方法
  - 如果此元方法是一个表，那么就在这个表中进行赋值

## 3.面向对象编程
- 因为Lua没有类的语法概念，所以通过创建一个专门被用作其他对象的原型对象来创建类．

### 1.创建类
```lua
-- 元类
Shape = {area = 0}

-- 基础类方法 new
function Shape:new (o,side)
  o = o or {}
  setmetatable(o, self) -- 将o设置成调用当前函数的表的元表
  self.__index = self -- 查询元表方法
  side = side or 0
  self.area = side*side;
  return o
end

-- 基础类方法 printArea
function Shape:printArea ()
  print("面积为 ",self.area)
end

-- 创建对象
myshape = Shape:new(nil,10) -- 调用上可以看成myshape = Shape.new(myshape,nil,10)

myshape:printArea() -- getmetatable(myshape).__index.printArea(myshape)
```

### 2.继承
- 继承了一个简单的类，来扩展派生类的方法，派生类中保留了继承类的成员变量和方法
```lua
Square = Shape:new()
-- 派生类方法 new
function Square:new (o,side)
  o = o or Shape:new(o,side) -- 如果元表存在，则使用元表，否则，从基类创建一个新的元表
  setmetatable(o, self)
  self.__index = self
  return o
end

-- 派生类方法 printArea
function Square:printArea ()
  print("正方形面积为 ",self.area)
  self:printSide()
end

function Square:printSide ()
    return self.printSide or 0
end

-- 创建对象
mysquare = Square:new(nil,10)

-- 定制派生类对象的专属函数实现
function mysquare:printSide()
    print("正方形边长为 ",math.sqrt(self.area))
end

mysquare:printArea()
```

### 3.多继承
- 子类拥有多个父类对象,在Lua中则是拥有两个元表
```lua
-- 在表plist的列表中查找k
local funcion search(k,plist)
  for i = 1,#plist do
    local v = plist[i][k]
    if v then return v end
  end
end

function createClass(...)
  local c = {} -- 新类
  local parents = {...} -- 父类列表

  -- 在父类列表中查找类缺失的方法
  setmetatable(c,{__index = function(t,k)
                  return search(k,parents)
                  end})

  -- 将c作为其实例的元表
  c.__index = c

  -- 为新类定义一个新的构造函数
  function c:new(o)
    o = o or {}
    setmetatable(o,c)
    return o
  end
  
  return c -- 返回新类
end

Named = {}

function Named:getname()
  return self.name
end

function Named:setname(n)
  self.name = n
end

-- 同时继承两个父类
NamedAccount = createClass(Account,Named)

account = NamedAccount:new{name = "Paul"}
print(account:getname()) --> Paul
```

### 4.私有性
- 一个表用来保存对象的状态，另一个表用于保存对象的操作(或接口)
```lua
function newAccount(iniialBalance)
  -- 私有属性
  local self = {balance = initialBalance}

  -- 公开方法
  local withdraw = function(v)
                    self.balance = self.balance - v
                   end

  local deposit = function(v)
                    self.balance = self.balance + v
                  end

  local getBalance = function () return self.balance end

  -- 打包成一个表，提供给外部进行操作
  return {
    withdraw = withdraw,
    deposit = deposit,
    getBalance = getBalance
  }
end

-- 使用
acc1 = newAccount(100.00)
acc1.withdraw(40)
print(acc1.getBalance()) --> 60
```

### 5.两种特殊的实现
- 单方法对象：将单独的方法以对象的表现形式返回
- 对偶表示：把表当作键,同时又把这个对象本身当作这个表的键