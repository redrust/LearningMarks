## 模式
- ### ***模式***是在某情景下,针对某问题的某种解决方案。
    - 情景就是应用某个模式的情况
    - 问题就是在某情景下达到的目标,也可以是某情景下的约束
    - 解决方案就是一个通用的设计,用来解决约束、达到目标
- ### 模式使用原则
    - 总是使用满足需要的最简单解决方案,不管它用不用模式
    - 不要过渡滥用设计模式,让模式自然而然的出现在设计中
    - 可以根据需要自由调整模式细节
### 桥接模式
- #### 桥接模式不止改变你的实现,也改变你的抽象
- 桥接模式通过将实现和抽象放在连个不同的类层次中而使用它们可以独立改变.
- 优点:
  - 将实现予以解耦,让它和页面之间不再永久绑定
  - 抽象和实现可以独立扩展,不会影响到对方
  - 对于“具体的抽象类”所做的改变,不会影响到客户
- 缺点:
  - 增加了复杂度
- 用途:
  - 适合使用在需要跨越多个平台的图形和窗口系统上
  - 需要用不同的方式改变接口和实现

### 生成器模式
- #### 封装一个产品的构造过程,并允许按步骤构造.
- 将目标对象的创建过程,封装进生成器中,然后让客户调用生成器为它创建目标对象.
- 优点:
  - 将一个复杂对象的创建过程封装起来
  - 允许对象通过多个步骤来创建,并可以改变过程
  - 向客户隐藏产品内部的实现
  - 产品的实现可以被替换
- 缺点:
  - 比工厂模式更复杂
- 用途: 
  - 经常被用来创建组合结构

### 责任链模式
- #### 一个以上的对象有机会能够处理某个请求
- 为某个请求创建一个对象链,每个对象依序检查此请求,并对其进行处理,或者将它传给链中的下一个对象.
- 优点:
  - 将请求的发送者和接受者解耦
  - 可以简化对象设计
  - 可以改变链内的成员或者调动它们的次序,动态的新增或者删除责任
- 缺点:
  - 并不保证请求一定会被执行
  - 可能不容易观察运行时的特征
- 用途:
  - 经常用于处理鼠标或者键盘一类的事件

### 享元模式(Flyweight)
- #### 某个类的一个实例提供许多“虚拟实例”
- 优点:
  - 减少运行时对象实例的个数,节省内存
  - 将许多“虚拟”对象的状态集中管理
- 缺点:
  - 一旦实现,单个对象将不能有额外的特殊行为
- 用途:
  - 当一个类有很多实例,而这些实例能被同一个方法控制时

### 解析器
- #### 为语言创建解析器
- 解析一个语言时,实现一个解析器模式定义的语法的类,并用一个解析器解释句子.每个语法规则都用一个类代表.

### 中介者模式
- #### 集中相关对象之间复杂的沟通和控制方式
- 中介者内包含了整个系统的控制逻辑.

### 备忘录模式
- #### 使目标对象返回之前的状态

### 原型模式
- #### 避免创建给定类的实例的过程很昂贵或很复杂
- 可以通过复制现有的实例来创建新的实例

### 访问者模式
- #### 使用访问者访问目标对象组合中的所有状态
