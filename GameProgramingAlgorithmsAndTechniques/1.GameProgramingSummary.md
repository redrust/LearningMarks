# 第一章:游戏编程概述
## 1.为什么早期的游戏使用汇编语言？
- 答:1)早期机能的限制,运行内存往往只有几K的大小,而且CPU主频只有几MHZ,为了能流畅渲染游戏画面和处理游戏逻辑,只能使用汇编语言来获取高性能开发。2)高级语言往往会加入很多不必要的特性.
## 2.什么是中间件？
- 答:在游戏开发中,一般有服务器中间件和引擎中间件,服务器中间件封装好了所有通信协议的细节,只需要处理游戏逻辑和数据库等操作.引擎中间件封装好了客户端实现的所有细节,设计者使用引擎进行开发时,只需要关心游戏逻辑的设计实现,而不需要关心渲染管线、模型等问题.在引擎中间件中,有提供全部功能的完全引擎框架,比如Unreal Engine和Unity,也有只提供部分功能实现的,如物理引擎Halvok Physics.只提供部分功能实现的可以让开发者更好的定制游戏功能实现策略,全引擎则提供了完整的解决方案.
## 3.选择一款经典的街机游戏,讲一下它们在经典游戏循环中每个阶段都做了什么？
- 答:经典游戏循环:一个死循环,内部先后执行1)获取用户输入,2)处理AI和场景物体运动逻辑,3)将画面渲染到屏幕上.为了限制帧率,将画面刷新速度和屏幕刷新速度同步起来,使用了帧刷新时间(deltaTime),来对帧率进行限制.
## 4.在传统游戏循环中,有什么渲染以外的输出？
- 答:还有音频输出,以及手柄震动等体感输出和网络数据.
## 5.一个简单的多线程游戏循环是怎么提升帧率的？
- 答:区分主线程和渲染线程,主线程处理游戏逻辑,将数据递送给渲染线程,渲染线程再将数据渲染到屏幕上.一般来说渲染线程比主线程慢一帧,这样渲染线程渲染当前帧的时候,主线程可以准备下一帧的数据,达到高利用率的效果.
- 标准答案:如果渲染大概使用了30ms,游戏世界的更新用了20ms,传统的游戏循环会花费每帧50ms.但是,如果渲染放入一条单独线程,那么就可以和传统游戏更新并行完成.在这种情况下,每帧时间总花费会降至30ms.
## 6.什么是输入延迟？多线程游戏循环是怎么导致延迟的？
- 答:在第一帧做的输入操作,第二帧主线程才开始处理,第四帧才能将输入结果刷新在屏幕上.因为渲染线程比主线程慢一帧.
## 7.真实时间和游戏时间有什么不同？什么情况下游戏时间会不同于真实时间？
- 答:真实时间:真实世界流逝的时间.游戏时间:游戏世界流逝的时间.比如暂停游戏、游戏发动加速减速一类的特殊技能.
## 8.改变下面依赖于30FPS的代码,使其不依赖帧率.
```
position.x += 3.0
position.y += 7.0
```
- 答:
```lua
--30FPS每帧33.3ms,60FPS每帧16.6ms
targetFrameTime = 33.3
while game is running
    realDeltaTime = time since last frame -- 帧刷新时间间隔,俗称增量时间
    gameDeltaTime = realDeltaTime * gameTimeFactor -- 游戏帧刷新时间间隔

    -- 刷新游戏世界,平滑每一帧游戏对象移动的距离
    position.x += 3.0 * gameDeltaTime
    position.y += 7.0 * gameDeltaTime

    -- 消耗多余的帧刷新时间,将帧刷新间隔恒定在某个数值
    while (time spent this frame) < targetFrameTime
        sleep(some time)
    end
end
```
## 9.在传统的游戏循环中,怎样强制锁定30FPS的帧率？
- 答:使用增量时间:从上一帧起流逝的时间,如果当前帧刷新花费的时间小于预定的帧刷新时间,那么阻塞其刷新,等时间达到预定的帧刷新时间,再进行下一帧的刷新,即可强制锁定目标帧率.
## 10.3个不同类型的游戏对象是什么？分别给例子.
- 答:1）游戏对象:更新和绘制都需要的对象.比如游戏中的玩家操控的角色、敌人等.2）静态对象:需要绘制,但是不需要更新的对象.比如场景大楼.3）触发器:需要更新,但不需要绘制的对象.比如陷阱和自动门等.